-- TODO
-- * сортировать все функции по именам
-- * разбить большие функции на мелкие

local hyper_msgs = require("hyper_trails.msgs")
local hyper_fmath = require("hyper_trails.fmath")
local hyper_geometry = require("hyper_trails.geometry")

go.property("use_world_position", false)
go.property("trail_width", 20)
go.property("trail_tint_color", vmath.vector4(1.0, 1.0, 1.0, 1.0))
go.property("segment_length_max", 0)
go.property("segment_length_min", 0)
go.property("points_count", 16)
go.property("points_limit", 0)
go.property("fade_tail_alpha", false)
go.property("shrink_tail_width", false)
go.property("texture_tiling", true)
go.property("trail_model_url", msg.url("#trail_model"))

local function set_vector_constant(self, i, off_x, off_y, v1, v2)
	local pos = vmath.vector4(v1.x - off_x, v1.y - off_y, v2.x - off_x, v2.y - off_y)

	model.set_constant(self.trail_model_url, "pos" .. (i - 1), pos)
end

local function set_tint_constant(self, i, tint)
	model.set_constant(self.trail_model_url, "tint" .. (i - 1), tint)
end

local function apply_vector_pairs_to_segment(self, row)
	local a = row.angle - math.pi / 2
	local w = row.width / 2

	row.v1 = vmath.vector3(math.cos(a) * w, math.sin(a) * w, 0) + row.pos
	row.v2 = vmath.vector3(math.cos(a + math.pi) * w, math.sin(a + math.pi) * w, 0) + row.pos

	if not row.new and row.prev ~= nil and row.prev.v1 ~= nil then
		local prev = row.prev

		local intersects = hyper_geometry.lines_intersects(row.v1, prev.v1, row.v2, prev.v2, false)
		if intersects then
			local v = row.v2
			row.v2 = row.v1
			row.v1 = v
		end
	end
end

local function make_angle(last, to)
	local new_angle = math.atan2(to.y - last.pos.y, to.x - last.pos.x)
	local angle = last.angle

	return new_angle
end

local function init_data(self, initial_pos)
	self._data = {}

	for i = 1, self._data_w do
		local tint = vmath.vector4(self.trail_tint_color)
		tint.w = 0

		self._data[i] = {
			pos = vmath.vector3(initial_pos),
			angle = 0,
			tint = tint,
			width = self.trail_width,
			prev = self._data[i - 1],
			dirty = true
		}
	end
end

local function init_props(self)
	if self.points_limit > self.points_count or self.points_limit == 0 then
		self.points_limit = self.points_count
	end

	-- if self.use_world_position then
	-- 	self.last_world_pos = go.get_world_position()
	-- end
end

local function set_uv_opts_constants(self)
	--if self.texture_tiling then
	--	model.set_constant(self.trail_model_url, "uv_opts", vmath.vector4(1, 0, 1, 0))
	--else
	--	model.set_constant(self.trail_model_url, "uv_opts", vmath.vector4(0, 1, self.points_count, 0))
	--end
end

local function set_data_constants(self)
	local local_pos = go.get_position()

	for i = 1, self._data_w do
		local d = self._data[i]
		set_vector_constant(self, i, local_pos.x, local_pos.y, d.v1, d.v2)
		-- set_tint_constant(self, i, d.tint)
	end
end

local function update_dirty_data(self)
	for i = 1, self._data_w do
		if self._data[i].dirty then
			apply_vector_pairs_to_segment(self, self._data[i])
			self._data[i].dirty = false
		end
	end
end

local function draw_trail(self)
	update_dirty_data(self)
	set_uv_opts_constants(self)
	set_data_constants(self)
end

local function last_data_points(self)
	return self._data[self._data_w - 1], self._data[self._data_w]
end

local function follow_position(self, new_position)
	local prev_point, last_point = last_data_points(self)
	local lp_dist = hyper_geometry.distance(prev_point.pos, last_point.pos)

	local new_point = nil
	local add_new_p = true
	if self.segment_length_min > 0 then 
		if lp_dist < self.segment_length_min then
			add_new_p = false
			new_point = last_point
			last_point = prev_point
		end
	end

	if add_new_p then
		new_point = self._data[1]
		for i = 1, self._data_w - 1 do
			self._data[i] = self._data[i + 1]
		end
	end

	-- if self.use_world_position then
	-- 	local delta_pos = go.get_world_position() - self.last_world_pos
	-- 	new_position = last_point.pos + delta_pos
	-- 	self.last_world_pos = go.get_world_position()
	-- end

	new_point.pos = new_position
	new_point.angle = make_angle(last_point, new_position)
	new_point.tint = vmath.vector4(self.trail_tint_color)
	new_point.width = self.trail_width
	new_point.prev = last_point
	new_point.dirty = true

	self._data[self._data_w] = new_point

	if self.fade_tail_alpha then
		for i = 1, self._data_w do
			local w = (i - 1) / (self._data_w - 1)
			if self._data[i].tint.w > w then
				self._data[i].tint.w = w
				self._data[i].dirty = true
			end
		end
	end

	if self.shrink_tail_width then
		for i = 1, self._data_w do
			self._data[i].width = self.trail_width * (i / self._data_w)
			self._data[i].dirty = true
		end
	end
end

local function reset_position(self, position)
	for i = 1, self._data_w do
		self._data[i].pos = vmath.vector3(position)
		self._data[i].dirty = true
	end
end

function init(self)
	self._data_w = self.points_count

	local initial_pos = go.get_position()

	init_props(self)
	init_data(self, initial_pos)
	draw_trail(self)
end

function final(self)
end

function update(self, dt)
	follow_position(self, go.get_position())
	draw_trail(self)
end

function on_message(self, message_id, message, sender)
	if message_id == hyper_msgs.RESET_POSITION then
		reset_position(self, go.get_position())
		draw_trail(self)
	end
end
